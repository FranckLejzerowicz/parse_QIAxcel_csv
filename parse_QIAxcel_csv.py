#!/usr/bin/env python

import argparse
import os, re
import time

__author__ = "Franck Lejzerowicz"
__copyright__ = "Copyright 2017, The Deep-Sea Microbiome Project"
__credits__ = ["Jan Pawlowski"]
__license__ = "GPL V3"
__version__ = "1.0"
__maintainer__ = "Franck Lejzerowicz"
__email__ = "franck.lejzerowicz@unige.ch"

def parseQIAxcel():
    """This script finds in the provided folder and its subfolders the .csv file(s) generated by the QIAxcel ScreeenGel software and outputs a simplified file with one entry per plate well (i.e. per sample). The output includes the plate name (i.e. QIAxcel run identifier), the plate well, the sample name (if provided in a separate file or in the QIAxcel report), and the final quantification for the user-defined size fragment range (dilution-corrected)."""
    parser=argparse.ArgumentParser()
    parser.add_argument('-fol', nargs = '?', default = '.', help = 'Folder to start parsing .csv files (default: .)')
    parser.add_argument('-out', nargs = '?', default = argparse.SUPPRESS, help = 'Output file name (default: starting folder name with time stamp and _qiaxcelOut.xls)')
    parser.add_argument('-dil', nargs = '?', type = float, required = True, help = 'Dilution factor (needed: one number)')
    parser.add_argument('-siz', nargs = '*', type = int, required = True, help = 'Fragment size range  (required: space-separated min and max numbers)')
    parser.add_argument('-ali', nargs = 2, default = ['15', '1000'], help = 'Alignment markers sizes  (default = 15 1000)')
    parser.add_argument('-sam', nargs = '*', default = argparse.SUPPRESS, help = 'File(s) for sample name mapping. A least three columns are needed: (1) plate name as before ".csv", (2) well coordinates(e.g. A5), (3+) sample name (could be composite but space-separated: e.g. sample1    DNA    20mg    positive    V4    ...)')
    parser.add_argument('--det', action = 'store_true', default = False, help = 'Show per size-fragment details (default = OFF)')
    parser.add_argument('--plate', action = 'store_true', default = False, help = 'Show results in plate layout (default = OFF)')
    args=vars(parser.parse_args())

    fold = args['fol']
    dil = args['dil']
    ali = args['ali']
    siz = map(int, args['siz'])
    if len(siz) > 2:
        print 'Too many arguments for -sizes\nProvide at least a min size value...\nExiting'
    details = args['det']

    files = get_qiaxcel_files(fold)
    print
    print 'Going to parse the following qiaxcel files:'
    for i in files:
        print '  -', i
    choice = raw_input('Continue? (y/n)')
    if choice.upper().startswith('Y')==False:
        return 0
    data, deta = parse_qiaxcel(files, ali, siz, dil)

    samNames = {}
    if args.has_key('sam'):
        nameFiles = args['sam']
        samNames = parse_samples_names(nameFiles)
    if args.has_key('out'):
        out = args['out']
    else:
        out = '%s/%s_%s_qiaxcelOut.xls' % (os.path.abspath(fold), os.path.abspath(fold).split('/')[-1], '-'.join(time.strftime("%Y,%m,%d,%H,%M").split(',')))
    plate = args['plate']
    write_output(out, data, deta, details, samNames, plate, ali, siz, dil)

def get_qiaxcel_files(fold):
    qfiles = []
    for root, dirs, files in os.walk(fold):
        for filin in files:
            if filin.endswith('.csv'):
                path = '%s/%s' % (root, filin)
                parsed = check_qiaxcel_format(path)
                if parsed:
                    qfiles.append(path)
    return qfiles

def check_qiaxcel_format(path):
    with open(path) as f:
        for ldx, line in enumerate(f):
            sline = line.strip().split(',')
            if ldx:
                plate = sline[0]
                well = sline[1]
                if ldx > 1:
                    if well != curWell:
                        return path
                    if sline[4] == 'name' and plate != curPlate and well != curWell:
                        return 0
                    elif sline[4] == 'size (bp)' and plate != curPlate and well != curWell:
                        return 0
                    elif sline[4] == 'conc (ng/ul)' and plate != curPlate and well != curWell:
                        return 0
                curPlate = sline[0]
                curWell = sline[1]
            elif sline != 'Filename,Well,Repeat,Sample Info,Property'.split(','):
                return 0

def parse_qiaxcel(files, ali, siz, dil):
    dat = {}
    det = {}
    for filin in files:
        prefix = filin.split('/')[-1].replace('.csv', '')
        dat[prefix] = {}
        det[prefix] = {}
        with open(filin) as f:
            for ldx, line in enumerate(f):
                sline = line.strip().split(',')
                if ldx:
                    well = sline[1]
                    rep = sline[2]
                    if sline[4] == 'name':
                        name = get_name(sline[4:])
                    elif sline[4] == 'size (bp)':
                        sizes = sline[5:]
                    elif sline[4] == 'conc (ng/ul)':
                        concs = sline[5:]
                    if ldx > 1 and well != curWell:
                        curDat, curDet = get_concData(sizes, concs, ali, siz, dil)
                        if curDat and curDet:
                            dat[prefix][curWell] = round(curDat, 3)
                            det[prefix][curWell] = curDet
                    curWell = sline[1]
        curDat, curDet = get_concData(sizes, concs, ali, siz, dil)
        if curDat and curDet:
            dat[prefix][curWell] = round(curDat, 3)
            det[prefix][well] = curDet
    return dat, det

def get_concData(sizes, concs, ali, siz, dil):
    sumData = 0
    detData = []
    if sizes:
        if [sizes[0], sizes[-1]] == ali:
            sizes = sizes[1:-1]
            concs = concs[1:-1]
            if sizes:
                for sdx, size in enumerate(sizes):
                    curConc = concs[sdx]
                    if curConc:
                        fConc = float(curConc)
                        if int(size) >= min(siz):
                            corrConc = round(fConc * dil, 3)
                            curDat = tuple([size, corrConc])
                            if len(siz) == 2:
                                if int(size) <= max(siz):
                                    sumData += corrConc
                                    detData.append(curDat)
                            else:
                                sumData += corrConc
                                detData.append(curDat)
                return sumData, detData
            else:
                return 0,0
        else:
            print 'Alignment markers not matching:'
            print '\tmeasured\t%s - %s' % (sizes[0], sizes[-1])
            print '\tuser\t%s - %s' % (siz[0], siz[-1])
            return 0,0
    else:
        return 0,0

def get_name(sline):
    if sline[-1] == 'name':
        return 0
    return '_'.join(sline[5:])

def parse_samples_names(nameFiles):
    names = {}
    for filin in nameFiles:
        with open(filin) as f:
            for line in f:
                if line.count(',')>=2:
                    sline = line.strip().split(',')
                else:
                    sline = line.strip().split()
                plate = sline[0]
                well = sline[1]
                sample = sline[2:]
                if names.has_key(plate)==False:
                    names[plate] = {}
                if names[plate].has_key(well):
                    print 'Well name (%s) appears twice in %s\nWill proceed without mapping the names to the wells' % (well, filin)
                    return 0
                names[plate][well] = sample
    return names

def write_output(out, data, deta, details, names, plate, ali, siz, dil):
    o = open(out, 'w')
    o.write('Parameters:\n')
    o.write('>sizeRange\t%s\n' % '-'.join(map(str, siz)))
    o.write('>alignmentMarker\t%s\n' % '-'.join(map(str, ali)))
    o.write('>dilutionFactor\t%s\n' % dil)
    if plate:
        for prefix in sorted(data):
            o.write('%s\n' % prefix)
            o.write('\t%s\n' % '\t'.join(map(str, range(1,13))))
            for row in 'ABCDEFGH':
                o.write(row)
                for col in range(1,13):
                    if col < 10:
                        col = '0%s' % col
                    curWell = '%s%s' % (row, col)
                    if data[prefix].has_key(curWell):
                        o.write('\t%s' % data[prefix][curWell])
                    else:
                        o.write('\tNA')
                o.write('\n')
    else:
        noValue = {}
        n2d = {}
        for prefix in sorted(data):
            noValue[prefix]={}
            if names:
                for plate in names:
                    if plate in prefix or prefix in plate:
                        for well in names[plate]:
                            noValue[prefix][well] = '_'.join(names[plate][well])
                        n2d[prefix] = plate
                        break
                else:
                    names = 0
            for well in sorted(data[prefix], key = lambda x: (x[0], int(x[1:]))):
                name = ['NA']
                if names:
                    if names[plate].has_key(well):
                        name = names[plate][well]
                        noValue[prefix].pop(well)
                o.write('%s\t%s\t%s\t%s\n' % (prefix, well, '_'.join(name), data[prefix][well]))
        for pfx, prefix in enumerate(sorted(data)):
            if len(noValue[prefix]):
                if pfx == 0:
                    o.write('\nmissingValues:\n')
                for well in sorted(noValue[prefix], key = lambda x: (x[0], int(x[1:]))):
                    name = noValue[prefix][well]
                    o.write('%s\t%s\t%s\n' % (prefix, well, name))
        if details:
            o.write('\nDetails per fragment size:\n')
            for well in sorted(deta[prefix], key = lambda x: (x[0], int(x[1:]))):
                name = ['NA']
                if names:
                    plate = n2d[prefix]
                    if names[plate].has_key(well):
                        name = names[plate][well]
                o.write('%s\t%s\t%s' % (prefix, well, '_'.join(name)))
                for fdx, frag in enumerate(deta[prefix][well]):
                    if fdx:
                        o.write('\t\t\t%s\n' % '\t'.join(map(str, frag)))
                    else:
                        o.write('\t%s\n' % '\t'.join(map(str, frag)))

        o.close()
    print 'Output file: %s' % os.path.abspath(out)

parseQIAxcel()
